"""
Copyright (c) Alejandro Ricoveri
m2s3: A mongodump straight to AWS S3

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---------------------------
MongoDB module:
~~~~~~~~~~~~~~
Make gzipped database backups via mongodump
"""


import os
import stat
import subprocess
import time
import tarfile
import sys
import uuid
from . import log
from .const import (
    MONGODB_DEFAULT_PORT,
    MONGODB_DEFAULT_MONGODUMP,
    MONGODB_DEFAULT_OUTPUT_DIR,
    MONGODB_DEFAULT_USER,
    MONGODB_DEFAULT_PWD
)


def _make_tarfile(src_dir):
    """
    Make gzipped tarball from a source directory

    :param src_dir: source directory
    :raises TypeError: if src_dir is not str
    """
    if type(src_dir) != str:
        raise TypeError('src_dir must be str')
    output_file = src_dir + ".tar.gz"
    log.msg("Wrapping tarball '{out}' ...".format(out=output_file))
    with tarfile.open(output_file, "w:gz") as tar:
        tar.add(src_dir, arcname=os.path.basename(src_dir))
    return output_file


def _chkstr(s, v):
    """
    Small routine for checking if a string is either empty or not
    even a string

    :param s: the string in question
    :param v: variable name
    """
    if type(s) != str:
        raise TypeError("{var} must be str".format(var=v))
    if not s:
        raise ValueError("{var} cannot be empty".format(var=v))


def _set_mongodb_host_val(key, default, mongodb_host, mongodb_defaults):
    """
    Set a value in a 'cascade' fashion for mongodb_host[key]

    Within 'mongodb', as a last resort, its hardcoded default value is going to
    be picked.

    :param key: key name
    :param default: default last resort value
    :param mongodb_host: mongodb 'host' entry
    :param mongodb_defaults: mongodb 'defaults' dict
    """
    # If mongodb_host[key] is not already set, its value is going to be picked
    # from mongodb_defaults[key]
    if not key in mongodb_host:
        if key in mongodb_defaults:
            mongodb_host[key] = mongodb_defaults[key]
        else:
        # BUT, if also mongodb_defaults[key] doesn't exist
        # the value picked is going to be 'default' as last resort
            mongodb_host[key] = default
        if key != 'user_name' and key != 'password':
            log.msg_debug("Setting default '{key}'='{value}' "
                          .format(key=key, value=mongodb_host[key]))

def _merge_dbs(default_dbs, host_dbs):
    return list(set(default_dbs + host_dbs))


def make_backup_files(**kwargs):
    """
    Backup all specified databases into a gzipped tarball

    :param data: a list containing mongodb-related parameters
    :param \*\*kwargs: arbitrary keyword arguments
    :raises TypeError: if an argument in kwargs does not have the type expected
    :raises ValueError: if an argument within kwargs has an invalid value
    """

    # Path to the mongodump executable
    mongodump = kwargs.get('mongodump', MONGODB_DEFAULT_MONGODUMP)
    # Output directory
    output_dir = kwargs.get('output_dir', MONGODB_DEFAULT_OUTPUT_DIR)

    # Type checks
    _chkstr(mongodump, 'mongodump')
    _chkstr(output_dir, 'output_dir')

    # List of mongodb hosts holding databases
    mongodb_hosts = kwargs.get('hosts', [])
    if len(mongodb_hosts) == 0:
        raise ValueError("No mongodb 'hosts' specified!")

    # Default values applied to each host if necessary,
    # this setting takes effect on a 'cascade' fashion.
    mongodb_defaults = kwargs.get('host_defaults', {})

    #dry run
    dry_run = kwargs.get('dry_run', False)

    # Create output directory if it does not exist
    if not os.path.exists(output_dir):
        log.msg_warn("Output path '{output}' does not exist, creating it ..."
                      .format(output=output_dir))
        # create the actual root output directory
        os.makedirs(output_dir)
        # set folder permissions to 0770
        os.chmod(output_dir, stat.S_IRWXU | stat.S_IRWXG)

    # Collected list of files generated by _make_backup_file
    mongodump_files = []

    # Backup cycle for each mongodb host
    for mongodb_host in mongodb_hosts:

        # For each host, its 'address' and 'name' are essential
        if not 'name' in mongodb_host:
            raise KeyError("No 'name' for host '{host}' specified!"
                           .format(host=mongodb_host['address']))
        _chkstr(mongodb_host['name'], 'name')

        if not 'address' in mongodb_host:
            raise KeyError("No 'address' specified!")
        _chkstr(mongodb_host['address'], 'address')


        """
        For these keys, the value is going to be set in
        in a 'cascade' fashion, that means that if the value is not already set,
        its value is going to be picked from the 'defaults'(mongodb_defaults)
        sub-section within 'mongodb', as a last resort, its hardcoded default
        value is going to be picked.
        """
        _set_mongodb_host_val('user_name', MONGODB_DEFAULT_USER,
                              mongodb_host, mongodb_defaults)
        _set_mongodb_host_val('password', MONGODB_DEFAULT_PWD,
                              mongodb_host, mongodb_defaults)
        _set_mongodb_host_val('port', MONGODB_DEFAULT_PORT,
                              mongodb_host, mongodb_defaults)

        """Merge dbs list with that of the host_defaults section (if any)"""
        if 'dbs' in mongodb_defaults:
            if 'dbs' in mongodb_host:
                mongodb_host['dbs'] = _merge_dbs(mongodb_defaults['dbs'],
                                                 mongodb_host['dbs'])
            else:
                mongodb_host['dbs'] = mongodb_defaults['dbs']

        # Add the file name to the list to be returned
        mongodump_file = (
            _make_backup_file(dry_run=dry_run, mongodump=mongodump,
                              output_dir=output_dir, **mongodb_host),
            mongodb_host['name']
        )
        mongodump_files.append(mongodump_file)

    # .. and finally, give it
    return mongodump_files


def _log_make_backup_file_settings(mongodb_host):
    host_copy = mongodb_host.copy()
    del host_copy['password']
    log.msg_debug("mongodb host '{name}': {host}"
                  .format(name=host_copy['name'], host=host_copy))


def _make_backup_file(**kwargs):
    # log settings
    _log_make_backup_file_settings(kwargs)

    # Path to the mongodump executable
    mongodump = kwargs.get('mongodump')
    # Output directory
    out = kwargs.get('output_dir')
    # Host and port
    address = kwargs.get('address')
    port = kwargs.get('port')
    # The user and password for connecting to the databases
    user = kwargs.get('user_name')
    passwd = kwargs.get('password')
    # databases
    dbs = kwargs.get('dbs', [])
    #dry run
    dry_run = kwargs.get('dry_run')
    # name
    name = kwargs.get('name')

    # Type checks
    _chkstr(name, 'name')
    _chkstr(address, 'address')
    _chkstr(user, 'user_name')
    _chkstr(passwd, 'password')

    # Check port
    if type(port) != int:
        raise TypeError('port must be int')
    # check valid range in port
    if port < 1 or port > 65535:
        raise ValueError('port must be between 1 and 65535')

    # Check dbs
    if type(dbs) != list or len(dbs) == 0:
        raise ValueError('dbs must at least one value')
    for db in dbs:
        if type(db) != str:
            raise TypeError('all values within dbs must be str')

    # The mongodump directory is going to have a name indicating
    # the UNIX timestamp corresponding to the current creation time
    now = time.strftime("%Y-%m-%d_%H%M", time.gmtime(time.time()))
    # A random UUID is appended to the output directory in order to
    # avoid name collisions
    f_uuid = uuid.uuid4().hex
    out_dir = "{out}/mongodump-{name}-{now}-{uuid}"\
                .format(name=name, out=out, now=now, uuid=f_uuid)
    # create the current backup directory
    os.makedirs(out_dir)
    log.msg_debug("Output directory: {out_dir}".format(out_dir=out_dir))

    # For each database specified, run mongodump on it
    for db in dbs:
        _mongodump(mongodump, address, port, user, passwd, db, out_dir, dry_run)
    # After all has been done, make a gzipped tarball from it
    return _make_tarfile(out_dir)


def _mongodump(mongodump, address, port, user, passwd, db, out_dir, dry_run):
    """
    Run mongodump on a database

    :param address: server host name or IP address
    :param port: server port
    :param user: user name
    :param passwd: password
    :param db: database name
    :raises OSError: if mongodump process returns error
    """

    # Log the call
    log.msg("mongodump [{mongodump}] db={db} "
                  "mongodb://{user}@{host}:{port} > {output}"
                  .format(mongodump=mongodump, user=user, host=address,
                          port=port, db=db, output=out_dir))

    # Prepare the call
    args = "{mongodump} --host {host}:{port} -d {db} -u {user} -p {passwd} " \
           "--authenticationDatabase admin -o {output}"\
          .format(mongodump=mongodump, host=address, port=port,
                  db=db, user=user, passwd=passwd, output=out_dir)

    if not dry_run:
        # Make the actual call to mongodump
        p = subprocess.Popen(args.split(),
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        # wait for the process to finish
        p.wait()

        # Print stdout and stderr from the mongodump process
        stdout_data, stderr_data = p.communicate()
        stdout_str = stdout_data.decode(sys.stdout.encoding)
        stderr_str = stderr_data.decode(sys.stdout.encoding)
        log.msg_debug("{mongodump} > {stdout}"
                      .format(mongodump=mongodump, stdout=stdout_str))
        if stderr_str != '':
            log.msg_err("{mongodump} > {stderr}"
                        .format(mongodump=mongodump, stderr=stderr_str))

        # In this way, we will know what went wrong on mongodump
        if p.returncode != 0:
            raise OSError("mongodump failed!. Reason: {reason}"
                          .format(reason=p.communicate()))
